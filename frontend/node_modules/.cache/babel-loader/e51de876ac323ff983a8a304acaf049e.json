{"ast":null,"code":"'use client';\n\nimport * as React from 'react';\n\nfunction areEqual(a, b) {\n  return a === b;\n}\n\nconst EMPTY_OBJECT = {};\n\nconst NOOP = () => {};\n/**\n * Gets the current state augmented with controlled values from the outside.\n * If a state item has a corresponding controlled value, it will be used instead of the internal state.\n */\n\n\nfunction getControlledState(internalState, controlledProps) {\n  const augmentedState = { ...internalState\n  };\n  Object.keys(controlledProps).forEach(key => {\n    if (controlledProps[key] !== undefined) {\n      augmentedState[key] = controlledProps[key];\n    }\n  });\n  return augmentedState;\n}\n/**\n * Defines an effect that compares the next state with the previous state and calls\n * the `onStateChange` callback if the state has changed.\n * The comparison is done based on the `stateComparers` parameter.\n */\n\n\nfunction useStateChangeDetection(parameters) {\n  const {\n    nextState,\n    initialState,\n    stateComparers,\n    onStateChange,\n    controlledProps,\n    lastActionRef\n  } = parameters;\n  const internalPreviousStateRef = React.useRef(initialState);\n  React.useEffect(() => {\n    if (lastActionRef.current === null) {\n      // Detect changes only if an action has been dispatched.\n      return;\n    }\n\n    const previousState = getControlledState(internalPreviousStateRef.current, controlledProps);\n    Object.keys(nextState).forEach(key => {\n      // go through all state keys and compare them with the previous state\n      const stateComparer = stateComparers[key] ?? areEqual;\n      const nextStateItem = nextState[key];\n      const previousStateItem = previousState[key];\n\n      if (previousStateItem == null && nextStateItem != null || previousStateItem != null && nextStateItem == null || previousStateItem != null && nextStateItem != null && !stateComparer(nextStateItem, previousStateItem)) {\n        onStateChange?.(lastActionRef.current.event ?? null, key, nextStateItem, lastActionRef.current.type ?? '', nextState);\n      }\n    });\n    internalPreviousStateRef.current = nextState;\n    lastActionRef.current = null;\n  }, [internalPreviousStateRef, nextState, lastActionRef, onStateChange, stateComparers, controlledProps]);\n}\n/**\n * The alternative to `React.useReducer` that lets you control the state from the outside.\n *\n * It can be used in an uncontrolled mode, similar to `React.useReducer`, or in a controlled mode, when the state is controlled by the props.\n * It also supports partially controlled state, when some state items are controlled and some are not.\n *\n * The controlled state items are provided via the `controlledProps` parameter.\n * When a reducer action is dispatched, the internal state is updated with the new values.\n * A change event (`onStateChange`) is then triggered (for each changed state item) if the new state is different from the previous state.\n * This event can be used to update the controlled values.\n *\n * The comparison of the previous and next states is done using the `stateComparers` parameter.\n * If a state item has a corresponding comparer, it will be used to determine if the state has changed.\n * This is useful when the state item is an object and you want to compare only a subset of its properties or if it's an array and you want to compare its contents.\n *\n * An additional feature is the `actionContext` parameter. It allows you to add additional properties to every action object,\n * similarly to how React context is implicitly available to every component.\n *\n * @template State - The type of the state calculated by the reducer.\n * @template Action - The type of the actions that can be dispatched.\n * @template ActionContext - The type of the additional properties that will be added to every action object.\n *\n * @ignore - internal hook.\n */\n\n\nexport function useControllableReducer(parameters) {\n  const lastActionRef = React.useRef(null);\n  const {\n    reducer,\n    initialState,\n    controlledProps = EMPTY_OBJECT,\n    stateComparers = EMPTY_OBJECT,\n    onStateChange = NOOP,\n    actionContext,\n    componentName = ''\n  } = parameters;\n  const controlledPropsRef = React.useRef(controlledProps);\n\n  if (process.env.NODE_ENV !== 'production') {\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    React.useEffect(() => {\n      Object.keys(controlledProps).forEach(key => {\n        if (controlledPropsRef.current[key] !== undefined && controlledProps[key] === undefined) {\n          console.error(`useControllableReducer: ${componentName ? `The ${componentName} component` : 'A component'} is changing a controlled prop to be uncontrolled: ${key}`);\n        }\n\n        if (controlledPropsRef.current[key] === undefined && controlledProps[key] !== undefined) {\n          console.error(`useControllableReducer: ${componentName ? `The ${componentName} component` : 'A component'} is changing an uncontrolled prop to be controlled: ${key}`);\n        }\n      });\n    }, [controlledProps, componentName]);\n  } // The reducer that is passed to React.useReducer is wrapped with a function that augments the state with controlled values.\n\n\n  const reducerWithControlledState = React.useCallback((state, action) => {\n    lastActionRef.current = action;\n    const controlledState = getControlledState(state, controlledProps);\n    const newState = reducer(controlledState, action);\n    return newState;\n  }, [controlledProps, reducer]);\n  const [nextState, dispatch] = React.useReducer(reducerWithControlledState, initialState); // The action that is passed to dispatch is augmented with the actionContext.\n\n  const dispatchWithContext = React.useCallback(action => {\n    dispatch({ ...action,\n      context: actionContext\n    });\n  }, [actionContext]);\n  useStateChangeDetection({\n    nextState,\n    initialState,\n    stateComparers: stateComparers ?? EMPTY_OBJECT,\n    onStateChange: onStateChange ?? NOOP,\n    controlledProps,\n    lastActionRef\n  });\n  return [getControlledState(nextState, controlledProps), dispatchWithContext];\n}","map":{"version":3,"sources":["F:/Web Projects/Web/Business Website/frontend/node_modules/@mui/base/utils/useControllableReducer.js"],"names":["React","areEqual","a","b","EMPTY_OBJECT","NOOP","getControlledState","internalState","controlledProps","augmentedState","Object","keys","forEach","key","undefined","useStateChangeDetection","parameters","nextState","initialState","stateComparers","onStateChange","lastActionRef","internalPreviousStateRef","useRef","useEffect","current","previousState","stateComparer","nextStateItem","previousStateItem","event","type","useControllableReducer","reducer","actionContext","componentName","controlledPropsRef","process","env","NODE_ENV","console","error","reducerWithControlledState","useCallback","state","action","controlledState","newState","dispatch","useReducer","dispatchWithContext","context"],"mappings":"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","sourcesContent":["'use client';\n\nimport * as React from 'react';\nfunction areEqual(a, b) {\n  return a === b;\n}\nconst EMPTY_OBJECT = {};\nconst NOOP = () => {};\n\n/**\n * Gets the current state augmented with controlled values from the outside.\n * If a state item has a corresponding controlled value, it will be used instead of the internal state.\n */\nfunction getControlledState(internalState, controlledProps) {\n  const augmentedState = {\n    ...internalState\n  };\n  Object.keys(controlledProps).forEach(key => {\n    if (controlledProps[key] !== undefined) {\n      augmentedState[key] = controlledProps[key];\n    }\n  });\n  return augmentedState;\n}\n/**\n * Defines an effect that compares the next state with the previous state and calls\n * the `onStateChange` callback if the state has changed.\n * The comparison is done based on the `stateComparers` parameter.\n */\nfunction useStateChangeDetection(parameters) {\n  const {\n    nextState,\n    initialState,\n    stateComparers,\n    onStateChange,\n    controlledProps,\n    lastActionRef\n  } = parameters;\n  const internalPreviousStateRef = React.useRef(initialState);\n  React.useEffect(() => {\n    if (lastActionRef.current === null) {\n      // Detect changes only if an action has been dispatched.\n      return;\n    }\n    const previousState = getControlledState(internalPreviousStateRef.current, controlledProps);\n    Object.keys(nextState).forEach(key => {\n      // go through all state keys and compare them with the previous state\n      const stateComparer = stateComparers[key] ?? areEqual;\n      const nextStateItem = nextState[key];\n      const previousStateItem = previousState[key];\n      if (previousStateItem == null && nextStateItem != null || previousStateItem != null && nextStateItem == null || previousStateItem != null && nextStateItem != null && !stateComparer(nextStateItem, previousStateItem)) {\n        onStateChange?.(lastActionRef.current.event ?? null, key, nextStateItem, lastActionRef.current.type ?? '', nextState);\n      }\n    });\n    internalPreviousStateRef.current = nextState;\n    lastActionRef.current = null;\n  }, [internalPreviousStateRef, nextState, lastActionRef, onStateChange, stateComparers, controlledProps]);\n}\n\n/**\n * The alternative to `React.useReducer` that lets you control the state from the outside.\n *\n * It can be used in an uncontrolled mode, similar to `React.useReducer`, or in a controlled mode, when the state is controlled by the props.\n * It also supports partially controlled state, when some state items are controlled and some are not.\n *\n * The controlled state items are provided via the `controlledProps` parameter.\n * When a reducer action is dispatched, the internal state is updated with the new values.\n * A change event (`onStateChange`) is then triggered (for each changed state item) if the new state is different from the previous state.\n * This event can be used to update the controlled values.\n *\n * The comparison of the previous and next states is done using the `stateComparers` parameter.\n * If a state item has a corresponding comparer, it will be used to determine if the state has changed.\n * This is useful when the state item is an object and you want to compare only a subset of its properties or if it's an array and you want to compare its contents.\n *\n * An additional feature is the `actionContext` parameter. It allows you to add additional properties to every action object,\n * similarly to how React context is implicitly available to every component.\n *\n * @template State - The type of the state calculated by the reducer.\n * @template Action - The type of the actions that can be dispatched.\n * @template ActionContext - The type of the additional properties that will be added to every action object.\n *\n * @ignore - internal hook.\n */\nexport function useControllableReducer(parameters) {\n  const lastActionRef = React.useRef(null);\n  const {\n    reducer,\n    initialState,\n    controlledProps = EMPTY_OBJECT,\n    stateComparers = EMPTY_OBJECT,\n    onStateChange = NOOP,\n    actionContext,\n    componentName = ''\n  } = parameters;\n  const controlledPropsRef = React.useRef(controlledProps);\n  if (process.env.NODE_ENV !== 'production') {\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    React.useEffect(() => {\n      Object.keys(controlledProps).forEach(key => {\n        if (controlledPropsRef.current[key] !== undefined && controlledProps[key] === undefined) {\n          console.error(`useControllableReducer: ${componentName ? `The ${componentName} component` : 'A component'} is changing a controlled prop to be uncontrolled: ${key}`);\n        }\n        if (controlledPropsRef.current[key] === undefined && controlledProps[key] !== undefined) {\n          console.error(`useControllableReducer: ${componentName ? `The ${componentName} component` : 'A component'} is changing an uncontrolled prop to be controlled: ${key}`);\n        }\n      });\n    }, [controlledProps, componentName]);\n  }\n\n  // The reducer that is passed to React.useReducer is wrapped with a function that augments the state with controlled values.\n  const reducerWithControlledState = React.useCallback((state, action) => {\n    lastActionRef.current = action;\n    const controlledState = getControlledState(state, controlledProps);\n    const newState = reducer(controlledState, action);\n    return newState;\n  }, [controlledProps, reducer]);\n  const [nextState, dispatch] = React.useReducer(reducerWithControlledState, initialState);\n\n  // The action that is passed to dispatch is augmented with the actionContext.\n  const dispatchWithContext = React.useCallback(action => {\n    dispatch({\n      ...action,\n      context: actionContext\n    });\n  }, [actionContext]);\n  useStateChangeDetection({\n    nextState,\n    initialState,\n    stateComparers: stateComparers ?? EMPTY_OBJECT,\n    onStateChange: onStateChange ?? NOOP,\n    controlledProps,\n    lastActionRef\n  });\n  return [getControlledState(nextState, controlledProps), dispatchWithContext];\n}"]},"metadata":{},"sourceType":"module"}