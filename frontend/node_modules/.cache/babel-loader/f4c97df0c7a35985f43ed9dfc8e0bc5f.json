{"ast":null,"code":"import { ListActionTypes } from './listActions.types';\n/**\n * Looks up the next valid item to highlight within the list.\n *\n * @param currentIndex The index of the start of the search.\n * @param lookupDirection Whether to look for the next or previous item.\n * @param items The array of items to search.\n * @param includeDisabledItems Whether to include disabled items in the search.\n * @param isItemDisabled A function that determines whether an item is disabled.\n * @param wrapAround Whether to wrap around the list when searching.\n * @returns The index of the next valid item to highlight or -1 if no valid item is found.\n */\n\nfunction findValidItemToHighlight(currentIndex, lookupDirection, items, includeDisabledItems, isItemDisabled, wrapAround) {\n  if (items.length === 0 || !includeDisabledItems && items.every((item, itemIndex) => isItemDisabled(item, itemIndex))) {\n    return -1;\n  }\n\n  let nextFocus = currentIndex;\n\n  for (;;) {\n    // No valid items found\n    if (!wrapAround && lookupDirection === 'next' && nextFocus === items.length || !wrapAround && lookupDirection === 'previous' && nextFocus === -1) {\n      return -1;\n    }\n\n    const nextFocusDisabled = includeDisabledItems ? false : isItemDisabled(items[nextFocus], nextFocus);\n\n    if (nextFocusDisabled) {\n      nextFocus += lookupDirection === 'next' ? 1 : -1;\n\n      if (wrapAround) {\n        nextFocus = (nextFocus + items.length) % items.length;\n      }\n    } else {\n      return nextFocus;\n    }\n  }\n}\n/**\n * Gets the next item to highlight based on the current highlighted item and the search direction.\n *\n * @param previouslyHighlightedValue The item from which to start the search for the next candidate.\n * @param offset The offset from the previously highlighted item to search for the next candidate or a special named value ('reset', 'start', 'end').\n * @param context The list action context.\n *\n * @returns The next item to highlight or null if no item is valid.\n */\n\n\nexport function moveHighlight(previouslyHighlightedValue, offset, context) {\n  const {\n    items,\n    isItemDisabled,\n    disableListWrap,\n    disabledItemsFocusable,\n    itemComparer,\n    focusManagement\n  } = context; // TODO: make this configurable\n  // The always should be an item highlighted when focus is managed by the DOM\n  // so that it's accessible by the `tab` key.\n\n  const defaultHighlightedIndex = focusManagement === 'DOM' ? 0 : -1;\n  const maxIndex = items.length - 1;\n  const previouslyHighlightedIndex = previouslyHighlightedValue == null ? -1 : items.findIndex(item => itemComparer(item, previouslyHighlightedValue));\n  let nextIndexCandidate;\n  let lookupDirection;\n  let wrapAround = !disableListWrap;\n\n  switch (offset) {\n    case 'reset':\n      if (defaultHighlightedIndex === -1) {\n        return null;\n      }\n\n      nextIndexCandidate = 0;\n      lookupDirection = 'next';\n      wrapAround = false;\n      break;\n\n    case 'start':\n      nextIndexCandidate = 0;\n      lookupDirection = 'next';\n      wrapAround = false;\n      break;\n\n    case 'end':\n      nextIndexCandidate = maxIndex;\n      lookupDirection = 'previous';\n      wrapAround = false;\n      break;\n\n    default:\n      {\n        const newIndex = previouslyHighlightedIndex + offset;\n\n        if (newIndex < 0) {\n          if (!wrapAround && previouslyHighlightedIndex !== -1 || Math.abs(offset) > 1) {\n            nextIndexCandidate = 0;\n            lookupDirection = 'next';\n          } else {\n            nextIndexCandidate = maxIndex;\n            lookupDirection = 'previous';\n          }\n        } else if (newIndex > maxIndex) {\n          if (!wrapAround || Math.abs(offset) > 1) {\n            nextIndexCandidate = maxIndex;\n            lookupDirection = 'previous';\n          } else {\n            nextIndexCandidate = 0;\n            lookupDirection = 'next';\n          }\n        } else {\n          nextIndexCandidate = newIndex;\n          lookupDirection = offset >= 0 ? 'next' : 'previous';\n        }\n      }\n  }\n\n  const nextIndex = findValidItemToHighlight(nextIndexCandidate, lookupDirection, items, disabledItemsFocusable, isItemDisabled, wrapAround); // If there are no valid items to highlight, return the previously highlighted item (if it's still valid).\n\n  if (nextIndex === -1 && previouslyHighlightedValue !== null && !isItemDisabled(previouslyHighlightedValue, previouslyHighlightedIndex)) {\n    return previouslyHighlightedValue;\n  }\n\n  return items[nextIndex] ?? null;\n}\n/**\n * Toggles the selection of an item.\n *\n * @param item Item to toggle.\n * @param selectedValues Already selected items.\n * @param selectionMode The number of items that can be simultanously selected.\n * @param itemComparer A custom item comparer function.\n *\n * @returns The new array of selected items.\n */\n\nexport function toggleSelection(item, selectedValues, selectionMode, itemComparer) {\n  if (selectionMode === 'none') {\n    return [];\n  }\n\n  if (selectionMode === 'single') {\n    // if the item to select has already been selected, return the original array\n    if (itemComparer(selectedValues[0], item)) {\n      return selectedValues;\n    }\n\n    return [item];\n  } // The toggled item is selected; remove it from the selection.\n\n\n  if (selectedValues.some(sv => itemComparer(sv, item))) {\n    return selectedValues.filter(sv => !itemComparer(sv, item));\n  } // The toggled item is not selected - add it to the selection.\n\n\n  return [...selectedValues, item];\n}\n/**\n * Handles item selection in a list.\n *\n * @param item - The item to be selected.\n * @param state - The current state of the list.\n * @param context - The context of the list action.\n * @returns The new state of the list after the item has been selected, or the original state if the item is disabled.\n */\n\nexport function handleItemSelection(item, state, context) {\n  const {\n    itemComparer,\n    isItemDisabled,\n    selectionMode,\n    items\n  } = context;\n  const {\n    selectedValues\n  } = state;\n  const itemIndex = items.findIndex(i => itemComparer(item, i));\n\n  if (isItemDisabled(item, itemIndex)) {\n    return state;\n  } // if the item is already selected, remove it from the selection, otherwise add it\n\n\n  const newSelectedValues = toggleSelection(item, selectedValues, selectionMode, itemComparer);\n  return { ...state,\n    selectedValues: newSelectedValues,\n    highlightedValue: item\n  };\n}\n\nfunction handleKeyDown(key, state, context) {\n  const previouslySelectedValue = state.highlightedValue;\n  const {\n    orientation,\n    pageSize\n  } = context;\n\n  switch (key) {\n    case 'Home':\n      return { ...state,\n        highlightedValue: moveHighlight(previouslySelectedValue, 'start', context)\n      };\n\n    case 'End':\n      return { ...state,\n        highlightedValue: moveHighlight(previouslySelectedValue, 'end', context)\n      };\n\n    case 'PageUp':\n      return { ...state,\n        highlightedValue: moveHighlight(previouslySelectedValue, -pageSize, context)\n      };\n\n    case 'PageDown':\n      return { ...state,\n        highlightedValue: moveHighlight(previouslySelectedValue, pageSize, context)\n      };\n\n    case 'ArrowUp':\n      if (orientation !== 'vertical') {\n        break;\n      }\n\n      return { ...state,\n        highlightedValue: moveHighlight(previouslySelectedValue, -1, context)\n      };\n\n    case 'ArrowDown':\n      if (orientation !== 'vertical') {\n        break;\n      }\n\n      return { ...state,\n        highlightedValue: moveHighlight(previouslySelectedValue, 1, context)\n      };\n\n    case 'ArrowLeft':\n      {\n        if (orientation === 'vertical') {\n          break;\n        }\n\n        const offset = orientation === 'horizontal-ltr' ? -1 : 1;\n        return { ...state,\n          highlightedValue: moveHighlight(previouslySelectedValue, offset, context)\n        };\n      }\n\n    case 'ArrowRight':\n      {\n        if (orientation === 'vertical') {\n          break;\n        }\n\n        const offset = orientation === 'horizontal-ltr' ? 1 : -1;\n        return { ...state,\n          highlightedValue: moveHighlight(previouslySelectedValue, offset, context)\n        };\n      }\n\n    case 'Enter':\n    case ' ':\n      if (state.highlightedValue === null) {\n        return state;\n      }\n\n      return handleItemSelection(state.highlightedValue, state, context);\n\n    default:\n      break;\n  }\n\n  return state;\n}\n\nfunction handleBlur(state, context) {\n  if (context.focusManagement === 'DOM') {\n    return state;\n  }\n\n  return { ...state,\n    highlightedValue: null\n  };\n}\n\nfunction textCriteriaMatches(nextFocus, searchString, stringifyItem) {\n  const text = stringifyItem(nextFocus)?.trim().toLowerCase();\n\n  if (!text || text.length === 0) {\n    // Make item not navigable if stringification fails or results in empty string.\n    return false;\n  }\n\n  return text.startsWith(searchString);\n}\n\nfunction handleTextNavigation(state, searchString, context) {\n  const {\n    items,\n    isItemDisabled,\n    disabledItemsFocusable,\n    getItemAsString\n  } = context;\n  const startWithCurrentItem = searchString.length > 1;\n  let nextItem = startWithCurrentItem ? state.highlightedValue : moveHighlight(state.highlightedValue, 1, context);\n\n  for (let index = 0; index < items.length; index += 1) {\n    // Return un-mutated state if looped back to the currently highlighted value\n    if (!nextItem || !startWithCurrentItem && state.highlightedValue === nextItem) {\n      return state;\n    }\n\n    if (textCriteriaMatches(nextItem, searchString, getItemAsString) && (!isItemDisabled(nextItem, items.indexOf(nextItem)) || disabledItemsFocusable)) {\n      // The nextItem is the element to be highlighted\n      return { ...state,\n        highlightedValue: nextItem\n      };\n    } // Move to the next element.\n\n\n    nextItem = moveHighlight(nextItem, 1, context);\n  } // No item matches the text search criteria\n\n\n  return state;\n}\n\nfunction handleItemsChange(items, previousItems, state, context) {\n  const {\n    itemComparer,\n    focusManagement\n  } = context;\n  let newHighlightedValue = null;\n\n  if (state.highlightedValue != null) {\n    newHighlightedValue = items.find(item => itemComparer(item, state.highlightedValue)) ?? null;\n  } else if (focusManagement === 'DOM' && previousItems.length === 0) {\n    newHighlightedValue = moveHighlight(null, 'reset', context);\n  } // exclude selected values that are no longer in the items list\n\n\n  const selectedValues = state.selectedValues ?? [];\n  const newSelectedValues = selectedValues.filter(selectedValue => items.some(item => itemComparer(item, selectedValue)));\n  return { ...state,\n    highlightedValue: newHighlightedValue,\n    selectedValues: newSelectedValues\n  };\n}\n\nfunction handleResetHighlight(state, context) {\n  return { ...state,\n    highlightedValue: moveHighlight(null, 'reset', context)\n  };\n}\n\nfunction handleHighlightLast(state, context) {\n  return { ...state,\n    highlightedValue: moveHighlight(null, 'end', context)\n  };\n}\n\nfunction handleClearSelection(state, context) {\n  return { ...state,\n    selectedValues: [],\n    highlightedValue: moveHighlight(null, 'reset', context)\n  };\n}\n\nexport function listReducer(state, action) {\n  const {\n    type,\n    context\n  } = action;\n\n  switch (type) {\n    case ListActionTypes.keyDown:\n      return handleKeyDown(action.key, state, context);\n\n    case ListActionTypes.itemClick:\n      return handleItemSelection(action.item, state, context);\n\n    case ListActionTypes.blur:\n      return handleBlur(state, context);\n\n    case ListActionTypes.textNavigation:\n      return handleTextNavigation(state, action.searchString, context);\n\n    case ListActionTypes.itemsChange:\n      return handleItemsChange(action.items, action.previousItems, state, context);\n\n    case ListActionTypes.resetHighlight:\n      return handleResetHighlight(state, context);\n\n    case ListActionTypes.highlightLast:\n      return handleHighlightLast(state, context);\n\n    case ListActionTypes.clearSelection:\n      return handleClearSelection(state, context);\n\n    default:\n      return state;\n  }\n}","map":{"version":3,"sources":["F:/Web Projects/Web/Business Website/frontend/node_modules/@mui/base/useList/listReducer.js"],"names":["ListActionTypes","findValidItemToHighlight","currentIndex","lookupDirection","items","includeDisabledItems","isItemDisabled","wrapAround","length","every","item","itemIndex","nextFocus","nextFocusDisabled","moveHighlight","previouslyHighlightedValue","offset","context","disableListWrap","disabledItemsFocusable","itemComparer","focusManagement","defaultHighlightedIndex","maxIndex","previouslyHighlightedIndex","findIndex","nextIndexCandidate","newIndex","Math","abs","nextIndex","toggleSelection","selectedValues","selectionMode","some","sv","filter","handleItemSelection","state","i","newSelectedValues","highlightedValue","handleKeyDown","key","previouslySelectedValue","orientation","pageSize","handleBlur","textCriteriaMatches","searchString","stringifyItem","text","trim","toLowerCase","startsWith","handleTextNavigation","getItemAsString","startWithCurrentItem","nextItem","index","indexOf","handleItemsChange","previousItems","newHighlightedValue","find","selectedValue","handleResetHighlight","handleHighlightLast","handleClearSelection","listReducer","action","type","keyDown","itemClick","blur","textNavigation","itemsChange","resetHighlight","highlightLast","clearSelection"],"mappings":"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","sourcesContent":["import { ListActionTypes } from './listActions.types';\n/**\n * Looks up the next valid item to highlight within the list.\n *\n * @param currentIndex The index of the start of the search.\n * @param lookupDirection Whether to look for the next or previous item.\n * @param items The array of items to search.\n * @param includeDisabledItems Whether to include disabled items in the search.\n * @param isItemDisabled A function that determines whether an item is disabled.\n * @param wrapAround Whether to wrap around the list when searching.\n * @returns The index of the next valid item to highlight or -1 if no valid item is found.\n */\nfunction findValidItemToHighlight(currentIndex, lookupDirection, items, includeDisabledItems, isItemDisabled, wrapAround) {\n  if (items.length === 0 || !includeDisabledItems && items.every((item, itemIndex) => isItemDisabled(item, itemIndex))) {\n    return -1;\n  }\n  let nextFocus = currentIndex;\n  for (;;) {\n    // No valid items found\n    if (!wrapAround && lookupDirection === 'next' && nextFocus === items.length || !wrapAround && lookupDirection === 'previous' && nextFocus === -1) {\n      return -1;\n    }\n    const nextFocusDisabled = includeDisabledItems ? false : isItemDisabled(items[nextFocus], nextFocus);\n    if (nextFocusDisabled) {\n      nextFocus += lookupDirection === 'next' ? 1 : -1;\n      if (wrapAround) {\n        nextFocus = (nextFocus + items.length) % items.length;\n      }\n    } else {\n      return nextFocus;\n    }\n  }\n}\n\n/**\n * Gets the next item to highlight based on the current highlighted item and the search direction.\n *\n * @param previouslyHighlightedValue The item from which to start the search for the next candidate.\n * @param offset The offset from the previously highlighted item to search for the next candidate or a special named value ('reset', 'start', 'end').\n * @param context The list action context.\n *\n * @returns The next item to highlight or null if no item is valid.\n */\nexport function moveHighlight(previouslyHighlightedValue, offset, context) {\n  const {\n    items,\n    isItemDisabled,\n    disableListWrap,\n    disabledItemsFocusable,\n    itemComparer,\n    focusManagement\n  } = context;\n\n  // TODO: make this configurable\n  // The always should be an item highlighted when focus is managed by the DOM\n  // so that it's accessible by the `tab` key.\n  const defaultHighlightedIndex = focusManagement === 'DOM' ? 0 : -1;\n  const maxIndex = items.length - 1;\n  const previouslyHighlightedIndex = previouslyHighlightedValue == null ? -1 : items.findIndex(item => itemComparer(item, previouslyHighlightedValue));\n  let nextIndexCandidate;\n  let lookupDirection;\n  let wrapAround = !disableListWrap;\n  switch (offset) {\n    case 'reset':\n      if (defaultHighlightedIndex === -1) {\n        return null;\n      }\n      nextIndexCandidate = 0;\n      lookupDirection = 'next';\n      wrapAround = false;\n      break;\n    case 'start':\n      nextIndexCandidate = 0;\n      lookupDirection = 'next';\n      wrapAround = false;\n      break;\n    case 'end':\n      nextIndexCandidate = maxIndex;\n      lookupDirection = 'previous';\n      wrapAround = false;\n      break;\n    default:\n      {\n        const newIndex = previouslyHighlightedIndex + offset;\n        if (newIndex < 0) {\n          if (!wrapAround && previouslyHighlightedIndex !== -1 || Math.abs(offset) > 1) {\n            nextIndexCandidate = 0;\n            lookupDirection = 'next';\n          } else {\n            nextIndexCandidate = maxIndex;\n            lookupDirection = 'previous';\n          }\n        } else if (newIndex > maxIndex) {\n          if (!wrapAround || Math.abs(offset) > 1) {\n            nextIndexCandidate = maxIndex;\n            lookupDirection = 'previous';\n          } else {\n            nextIndexCandidate = 0;\n            lookupDirection = 'next';\n          }\n        } else {\n          nextIndexCandidate = newIndex;\n          lookupDirection = offset >= 0 ? 'next' : 'previous';\n        }\n      }\n  }\n  const nextIndex = findValidItemToHighlight(nextIndexCandidate, lookupDirection, items, disabledItemsFocusable, isItemDisabled, wrapAround);\n\n  // If there are no valid items to highlight, return the previously highlighted item (if it's still valid).\n  if (nextIndex === -1 && previouslyHighlightedValue !== null && !isItemDisabled(previouslyHighlightedValue, previouslyHighlightedIndex)) {\n    return previouslyHighlightedValue;\n  }\n  return items[nextIndex] ?? null;\n}\n\n/**\n * Toggles the selection of an item.\n *\n * @param item Item to toggle.\n * @param selectedValues Already selected items.\n * @param selectionMode The number of items that can be simultanously selected.\n * @param itemComparer A custom item comparer function.\n *\n * @returns The new array of selected items.\n */\nexport function toggleSelection(item, selectedValues, selectionMode, itemComparer) {\n  if (selectionMode === 'none') {\n    return [];\n  }\n  if (selectionMode === 'single') {\n    // if the item to select has already been selected, return the original array\n    if (itemComparer(selectedValues[0], item)) {\n      return selectedValues;\n    }\n    return [item];\n  }\n\n  // The toggled item is selected; remove it from the selection.\n  if (selectedValues.some(sv => itemComparer(sv, item))) {\n    return selectedValues.filter(sv => !itemComparer(sv, item));\n  }\n\n  // The toggled item is not selected - add it to the selection.\n  return [...selectedValues, item];\n}\n\n/**\n * Handles item selection in a list.\n *\n * @param item - The item to be selected.\n * @param state - The current state of the list.\n * @param context - The context of the list action.\n * @returns The new state of the list after the item has been selected, or the original state if the item is disabled.\n */\nexport function handleItemSelection(item, state, context) {\n  const {\n    itemComparer,\n    isItemDisabled,\n    selectionMode,\n    items\n  } = context;\n  const {\n    selectedValues\n  } = state;\n  const itemIndex = items.findIndex(i => itemComparer(item, i));\n  if (isItemDisabled(item, itemIndex)) {\n    return state;\n  }\n\n  // if the item is already selected, remove it from the selection, otherwise add it\n  const newSelectedValues = toggleSelection(item, selectedValues, selectionMode, itemComparer);\n  return {\n    ...state,\n    selectedValues: newSelectedValues,\n    highlightedValue: item\n  };\n}\nfunction handleKeyDown(key, state, context) {\n  const previouslySelectedValue = state.highlightedValue;\n  const {\n    orientation,\n    pageSize\n  } = context;\n  switch (key) {\n    case 'Home':\n      return {\n        ...state,\n        highlightedValue: moveHighlight(previouslySelectedValue, 'start', context)\n      };\n    case 'End':\n      return {\n        ...state,\n        highlightedValue: moveHighlight(previouslySelectedValue, 'end', context)\n      };\n    case 'PageUp':\n      return {\n        ...state,\n        highlightedValue: moveHighlight(previouslySelectedValue, -pageSize, context)\n      };\n    case 'PageDown':\n      return {\n        ...state,\n        highlightedValue: moveHighlight(previouslySelectedValue, pageSize, context)\n      };\n    case 'ArrowUp':\n      if (orientation !== 'vertical') {\n        break;\n      }\n      return {\n        ...state,\n        highlightedValue: moveHighlight(previouslySelectedValue, -1, context)\n      };\n    case 'ArrowDown':\n      if (orientation !== 'vertical') {\n        break;\n      }\n      return {\n        ...state,\n        highlightedValue: moveHighlight(previouslySelectedValue, 1, context)\n      };\n    case 'ArrowLeft':\n      {\n        if (orientation === 'vertical') {\n          break;\n        }\n        const offset = orientation === 'horizontal-ltr' ? -1 : 1;\n        return {\n          ...state,\n          highlightedValue: moveHighlight(previouslySelectedValue, offset, context)\n        };\n      }\n    case 'ArrowRight':\n      {\n        if (orientation === 'vertical') {\n          break;\n        }\n        const offset = orientation === 'horizontal-ltr' ? 1 : -1;\n        return {\n          ...state,\n          highlightedValue: moveHighlight(previouslySelectedValue, offset, context)\n        };\n      }\n    case 'Enter':\n    case ' ':\n      if (state.highlightedValue === null) {\n        return state;\n      }\n      return handleItemSelection(state.highlightedValue, state, context);\n    default:\n      break;\n  }\n  return state;\n}\nfunction handleBlur(state, context) {\n  if (context.focusManagement === 'DOM') {\n    return state;\n  }\n  return {\n    ...state,\n    highlightedValue: null\n  };\n}\nfunction textCriteriaMatches(nextFocus, searchString, stringifyItem) {\n  const text = stringifyItem(nextFocus)?.trim().toLowerCase();\n  if (!text || text.length === 0) {\n    // Make item not navigable if stringification fails or results in empty string.\n    return false;\n  }\n  return text.startsWith(searchString);\n}\nfunction handleTextNavigation(state, searchString, context) {\n  const {\n    items,\n    isItemDisabled,\n    disabledItemsFocusable,\n    getItemAsString\n  } = context;\n  const startWithCurrentItem = searchString.length > 1;\n  let nextItem = startWithCurrentItem ? state.highlightedValue : moveHighlight(state.highlightedValue, 1, context);\n  for (let index = 0; index < items.length; index += 1) {\n    // Return un-mutated state if looped back to the currently highlighted value\n    if (!nextItem || !startWithCurrentItem && state.highlightedValue === nextItem) {\n      return state;\n    }\n    if (textCriteriaMatches(nextItem, searchString, getItemAsString) && (!isItemDisabled(nextItem, items.indexOf(nextItem)) || disabledItemsFocusable)) {\n      // The nextItem is the element to be highlighted\n      return {\n        ...state,\n        highlightedValue: nextItem\n      };\n    }\n    // Move to the next element.\n    nextItem = moveHighlight(nextItem, 1, context);\n  }\n\n  // No item matches the text search criteria\n  return state;\n}\nfunction handleItemsChange(items, previousItems, state, context) {\n  const {\n    itemComparer,\n    focusManagement\n  } = context;\n  let newHighlightedValue = null;\n  if (state.highlightedValue != null) {\n    newHighlightedValue = items.find(item => itemComparer(item, state.highlightedValue)) ?? null;\n  } else if (focusManagement === 'DOM' && previousItems.length === 0) {\n    newHighlightedValue = moveHighlight(null, 'reset', context);\n  }\n\n  // exclude selected values that are no longer in the items list\n  const selectedValues = state.selectedValues ?? [];\n  const newSelectedValues = selectedValues.filter(selectedValue => items.some(item => itemComparer(item, selectedValue)));\n  return {\n    ...state,\n    highlightedValue: newHighlightedValue,\n    selectedValues: newSelectedValues\n  };\n}\nfunction handleResetHighlight(state, context) {\n  return {\n    ...state,\n    highlightedValue: moveHighlight(null, 'reset', context)\n  };\n}\nfunction handleHighlightLast(state, context) {\n  return {\n    ...state,\n    highlightedValue: moveHighlight(null, 'end', context)\n  };\n}\nfunction handleClearSelection(state, context) {\n  return {\n    ...state,\n    selectedValues: [],\n    highlightedValue: moveHighlight(null, 'reset', context)\n  };\n}\nexport function listReducer(state, action) {\n  const {\n    type,\n    context\n  } = action;\n  switch (type) {\n    case ListActionTypes.keyDown:\n      return handleKeyDown(action.key, state, context);\n    case ListActionTypes.itemClick:\n      return handleItemSelection(action.item, state, context);\n    case ListActionTypes.blur:\n      return handleBlur(state, context);\n    case ListActionTypes.textNavigation:\n      return handleTextNavigation(state, action.searchString, context);\n    case ListActionTypes.itemsChange:\n      return handleItemsChange(action.items, action.previousItems, state, context);\n    case ListActionTypes.resetHighlight:\n      return handleResetHighlight(state, context);\n    case ListActionTypes.highlightLast:\n      return handleHighlightLast(state, context);\n    case ListActionTypes.clearSelection:\n      return handleClearSelection(state, context);\n    default:\n      return state;\n  }\n}"]},"metadata":{},"sourceType":"module"}